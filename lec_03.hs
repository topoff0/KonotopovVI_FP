----------------------------------------------------------------
-- Лекция 03 Введение в Haskell. Списки и рекурсивные функции --
----------------------------------------------------------------

module Lec03 where

{-
                                         -------------
                                         | Paradigms |
                                         -------------
                                               |
                       ------------------------+-----------------------
                       |                                              |
                --------------                                ===============
                | Imperative |                                ∥ Declarative ∥
                --------------                                ===============
                       |                                              |
      -----------------+----------------               ---------------+----------------
      |                |               |               |              |               |
--------------   ------------   --------------     ---------   ==============   ------------
| Procedural |   |  Object  |   |  Parallel  |     | Logic |   ∥ Functional ∥   | Database |
--------------   | Oriented |   | Processing |     ---------   ==============   ------------
                 ------------   ------------- 

Императивное – инструкции (что нужно сделать?).
    - инструкции изменяют состояние вычислителя
    - выполняются последовательно
    - могут выполняться нелинейно (if, for, switch, ...)
    - выполняется присвоение
    - завершается по достижении последней инструкции

Декларативное – спецификация (как это устроено?). 
    - выполнение программы - это редукция/вычисление выражения
    - выражения - это спецификации/функции



Особенности функционального программирования:
    - нет переменных и операторов присваивания
    - нет строгой последовательности операций
    - нет циклов
    - рекурсия
    - функции высших порядков
    - чистые функции (функции без побочных эффектов)
    - ленивые вычисления (отложенные вычисления с возможностью форсирования)
    - строгая типизация
    - модульность
    - бесконечные структуры

Свобода VS Безопасность
Свобода - степень ограничений накладываемых на возможности программиста изменять 
            состояние программы или работать с ресурсами памяти, файлов, потоков, ...  
Безопасность - описывает вероятность того, что программа изначально свободна 
            от неопределенного поведения и ошибок.
Эти два свойства находятся в обратной зависимости: 
    чем больше возможностей выполнять опасные операции предоставляет язык, 
    тем ниже безопасность и наоборот. 



--------------------------------------------------------
Декларативный и императивный подходы к программированию
Сравним рецепты приготовления шоколадного торта:

Императивный:
1. Растопите масло на сковороде на слабом огне
2. Добавьте шоколад
3. Разбейте в миску 8 яиц
4. Добавьте муку, сахар и разрыхлитель
5. Тщательно перемещайте с помощью миксера
6. Добавьте масло-шоколадную смесь
7. Перелейте тесто для шоколадного торта на противень
8. Выпекайте 25 минут при температуре 200C

    - Что если я хочу сделать лимонный торт?
    Шаги 1, 2 и 6 не подходят для любого торта
    Каждый шаг изменяет состояние, а некоторые шаги зависят от состояния

    Для лимонного тора нужно писать новый алгоритм (или координально менять текущий)



Декларативный:
> (Масло-шоколадная смесь) состоит из растопленных на слабом огне масла и шоколада
> [Тесто для торта] состоит из 8 взбитых яиц, муки, сахара и разрыхлителя
> {Тесто для шоколадного торта} – это [тесто для торта], перемешанное с (масло-шоколадной смесью)
> Шоколадный торт – это {тесто для шоколадного торта}, выпеченное в духовке при 200C в течение 25 минут.

    - Здесь вообще нет указаний какие шаги выполнять
    Есть определение промежуточных результатов
    Код состоит из рекурсивных определений, которые сводятся к базовым компонентам

    Если нужен лимонный торт, то нужно заменить определение масло-шоколадной смеси на лимонную. 
    Определение теста останется неизменным, а в финальном результате нет упоминания базовых составляющих.
    ! Нет последовательности действий ! Не важно в каком порядке выполнять те или иные шаги.

--------------------------------------------------------
-}



{-
Haskell - чистый функциональный язык программирования с «ленивой» семантикой и полиморфной статической типизацией.
    - компилируемый
    - автоматическая сборка мусора
    - поддержка параллелизма
    - поддержка конкурентности
    - высокая степень абстракции (упрощает работу со сложными высоконагруженными системами)

--------------------------------------------------------
Код на Haskell гарантированно не имеет побочных эффектов
--------------------------------------------------------

Haskell toolchain:
- компилятор языка GHC (Glasgow Haskell Compiler)
- интерактивный интерпретатор GHCi
- утилита для управления проектами stack (a cross-platform program for developing Haskell projects)
- утилита для управления пакетами cabal (the Cabal installation tool for managing Haskell software)

Версии:
- ghc --version  
version 9.14.1
- stack --version 
Version 3.9.1
- cabal --version 
version 3.14.2.0


Базовые команды необходимые для выполнения первого практического задания:
    ghci - запуск интерактивной среды в терминале
    :l fileName.hs - загрузка соержимого файла в интерактивную среду
    :r - перезагрузка файла в интерактивную среду
    :t functionName - запрос типа функции или выражения
    :q - выход из интерактивной среды в обратно в терминал

*.hs - расширение файла содержащего код на Haskell



--------------------------------------------------------

Связываение переменных (переменной в рамках модуля должно быть уникальным):
variableName = variableValue
Например:
a = 2


Как написать функцию?
Использование сравнения с образцом (pattern matching)
    каждая строчка функции это образец (определение) 
    с которм будет сравниваться имя и аргументы

Функция одной переменной:
functionName :: ArgumentType -> ResultType
functionName    argumentName =  resultExpression
Например:
-}
addOneToInt :: Int -> Int
addOneToInt    arg =  arg + 1

{-
Функция нескольких переменных:
functionName :: Argument1Type -> Argument2Type -> Argument3Type -> ResultType
functionName    argument1Name    argument2Name    argument3Name =  resultExpression
Например:
-}
addThreeInts :: Int -> Int -> Int -> Int
addThreeInts    arg1   arg2   arg3 = arg1 + arg2 + arg3

{-
Частичное применение функций:
Применение одного или нескольких аргументов к функции и получение в итоге функции с меньшим числом агрументов.
addOneToTwoInts :: Int -> Int -> Int
addOneToTwoInts    arg2   arg3 = addThreeInts 1 arg2 arg3
Эквивалентная запись:
-}
addOneToTwoInts arg2 arg3 = addThreeInts 1 arg2 arg3
addOneTwoTimesToInt arg3 = addThreeInts 1 1 arg3

{-
Бесточечный стиль:
Аргументы справа при аппликации можно не писать.
addOneToTwoInts = addThreeInts 1
addOneTwoTimesToInt = addThreeInts 1 1

Определение через λ:
addOneToTwoInts = (\x y -> addThreeInts 1 x y)
addOneTwoTimesToInt arg3 = (\x -> addThreeInts 1 1 x) arg3


Области видимости:
-}
xx = 2 + 2 -- видно возде
add1 yy = yy + xx -- yy - локальная переменная
add2 yy = (\xx -> yy + xx) 3 -- yy - локальная переменная функции, xx - локальная переменная λ выражения
add3 yy = (\yy -> (\xx -> yy + xx) 1 ) 2 -- yy - локальная переменная функции, yy - локальная переменная λ выражения, xx - локальная переменная λ выражения
q q = \q -> q -- первая q - имя функции, вторая - аргумент функции видный только внутри функции, третья - аргумент лямбды, четвертый - тело терма


{-
Локальные функции и переменные
where VS let in
-}
doubleDouble1 x = dubs * 2
    where dubs  = iddub * 2 -- отступы!
          iddub = x

sumSquareOrSquareSum2 x y = let sumSquare = x ^ 2 + y ^ 2
                                squareSum = (x + y) ^ 2
                            in
                                if sumSquare > squareSum
                                    then sumSquare
                                    else squareSum
-- (let x = 3 in x * 2) + 4



{-
Функции высшего порядка:
Функции принимающие на вход функции (функции как аргументы)

higherOrderFunctionName :: InputFunctionType1 -> ArgumentType -> Resulttype
higherOrderFunctionName    inputFunction         argument     = resultExpressionWithHOF


Есть функции:
1 прибавляет единицу к числу если оно четное
2 умножает число на два если оно четное
3 возвести число в квадрат если оно четное

У них есть общие части, которые можно обобщить
-}

ifEvenInc0 :: Int -> Int
ifEvenInc0    n   = if even n
    then n + 1
    else n

ifEvenDouble0 :: Int -> Int
ifEvenDouble0    n   = if even n
    then n * 2
    else n

ifEvenSquare0 :: Int -> Int
ifEvenSquare0    n   = if even n
    then n ^ 2
    else n

ifEven :: (Int -> Int) -> Int -> Int
ifEven    myFunction      n   =  if even n then myFunction n else n

inc :: Int -> Int
inc n = n + 1

ifEvenInc :: Int -> Int
ifEvenInc n = ifEven inc n

ifEvenDouble :: Int -> Int
ifEvenDouble n = ifEven (\x -> x * 2) n



{-
Базовые типы:

Bool — булево значение;
Char — символ Юникода;
Int, Integer — целые числа;
Float, Double — числа с плавающей точкой;
type1 -> type2 — тип функции;
(type1, type2, ..., typeN) — тип кортежа, N>1;
() — единичный тип, с одной константой ();
[type1] — тип списка с элементами типа type1.

String = [Char]

:: -- оператор типизации

Можно хардкодить типы конкретных переменных и выражений прямо в строке или выражении:
[1,2,3] :: [] Double
2 :: Integer
a = (\x -> x) :: Int -> Int
a "Hello"
a = (\x -> x) ([1,2,3] :: [] Double)


Контейнерные типы:


Кортежи (tuples)
    Минимальный размер - 2 (~ до 62)
    Хранят значения произвольных типов
    Кортежи разных размеров - это разные типы, автоматического приведения нет
    ! скобки используются в основном для кортежей !

(,) 2 's' -- префиксный стиль
(2, 's') -- мисфиксный стиль
(True, 2.0, "Hello")
Функции для получения первого и второго значения пары: fst, snd


Списки (lists)
    Все элементы одного типа
    Два конструктора : и []

[] - пустой список
: - присоединение головы списка к хвосту

Конструкторы списка:
[] :: [a]
(:) :: a -> [a] -> [a]

1 : 2 : 3 : 4 : [] = (1 : (2 : (3 : (4 : []))))
(1 : 2) : 3 : 4 : [] - что происходит в этой строчке?

Связывание с образцом
(x,y) = (2*3, "Hello")
[a1,b1,c1] = "123"
[a2,b2,c2] = "1234"
[a3,b3,c3] = reverse "1234"
a3

Сравнение с образцом
fstOfSnd (x,(y,z)) = y
fstOfSnd ('z',(33,True))


Базовые функции для работы со списками:
head - получения первого элемента 
tail - получения хвоста списка
reverse - разворот списка
null - проверка на пустоту
...
-}

myReverse :: [a] -> [a]
myReverse xs = localRev xs []
    where localRev [] ys     = ys -- localRev это локальная функция (ее нельзя вызвать извне функции myReverse)
          localRev (z:zs) ys = localRev zs (z : ys) -- как работает эта строчка с учетом того,
                                                    -- что список заканчивается пустым списком
                                                    -- (1 : ... : [])



{-
Как написать рекурсивную функцию?
1 Определите типы выражения
2 Напишите базу рекурсии (может быть несколько)
3 Напишите рекурсивное выражение (может быть несколько)

recursionFunctionName :: Type1 -> Type2 -> Type3
recursionFunctionName    arg1     arg2  = recursionBase
recursionFunctionName    arg1     arg2  = action recursionFunctionName arg1 arg2
...

Примеры:
    - определить количество элементов в списке
1 какой тип может быть функции?
в списке могут быть любые элементы поэтому берем полиморфный список в качестве входного значения [a]
число элементов всегда целое число поэтому берем целые числа в качестве результата Int
нужно говорящее имя функции, например myLength
из выше сказанного получим следующий тип выражения:
myLength :: [a] -> Int

2 какая база рекурсии?
базовый случай - это пустой список и в нем ноль элементов. ничего меньше пустого списка получить не можем
тогда нужно написать определение: функция myLength принимающая пустой список - это ноль элементов в списке
подходит ли баз рекурсии под тип из пункта 1?
да, на входе список, а на выходе целое число
есть ли еще какие-то базовые случаи? вроде нет, но если, что вернемся сюда на этапе отладки 
итого база рекурсии:
myLength [] = 0

3 какое должно быть рекурсивное выражение?
список состоит из значений одного типа которые соединены конструктором : и завершается []
используя сравнение с образцом я могу разбирать список на голову и хвост (x : xs) 
причем сравнение будет работать с аргументом который я передам (т.е. слева от равно (справа от равно нет сравнения, там создание списка))
у меня полиморфные типы содержимого списка, но так как я просто считаю их, то это не важно
я могу просто выкидывать элементы на каждом шаге и каждый шаг просто прибавлять к результату единицу
напишем определение: функция myLength принимает список и сравнивает его с образцом, который разделяет список на голову и хвост - это единица плюс рекурсивный вызов функции myLength на хвосте списка
подходит ли это определение с типом из пункта 1?
да, на входе список, а на выходе целое число плюс функция, которая возвращает число (и эта сумма является числом)
myLength (x : xs) = 1 + myLength xs

проверим что это работает:
-}
myLength :: [a] -> Int
myLength [] = 0
myLength (x : xs) = 1 + myLength xs

{-
    - суммировать все элементы в списке
такая функция есть в стандартной библиотеке можно запросить ее тип
:t sum
и посмотреть как она ведет себя на различных входных данных
sum [1,2,3]
sum []
sum ["Hello", "World"] 

1 ...
2 ...
3 ...

    - сконкатенировать список строк
concat VS (++)
1 ...
2 ...
3 ...

-}



{- 
Другие способы записи рекурсивных выражений
на примере факториала
Конструкция if-then-else не может быть использована без else, т.к. if-then не является функцией
-}
factorial0 n = if n > 1
               then n * factorial0 (n - 1)
               else 1

factorial1 n = if n == 0
               then 1
               else n * factorial1 (n - 1)

factorial2 n = if n < 0
               then error "factorial: negative argument"
               else if n > 1
                    then n * factorial2 (n-1)
                    else 1

factorial3 n = helper 1 n
helper acc n = if n > 1
               then helper (acc * n) (n - 1) -- накапливание значения в аккумуляторе
               else acc

factorial4 n' = helper 1 n'
                where helper acc n = if n > 1 -- локальное связывание функции в where
                                     then helper (acc * n) (n - 1)
                                     else acc



{-
Охранные выражения (guards)
добавляют уловную логику в механизм сопоставления с образцом (т.е. можно проверить свойства аргументов до выполнения вычислений)
проверка происходит сверху вниз до первого верного условия
позволяют избегать нагромождений if-then-else
-}
classifyNumber x | x < 0     = "Negative"
                 | x == 0    = "Zero"
                 | x < 10    = "Small positive"
                 | x < 100   = "Medium positive"
                 | otherwise = "Large positive"

roots a b c | discriminant < 0 = error "No real roots"
            | discriminant == 0 = (x1, x1)
            | otherwise        = (x1, x2)
            where                          -- позволяет использовать discriminant несколько раз в guards
                discriminant = b^2 - 4*a*c
                dSqrt = sqrt discriminant
                x1 = (-b - dSqrt) / (2*a)
                x2 = (-b + dSqrt) / (2*a)



{-
Стандартные оператор и их приоритеты:

infixr 10               -- применение с наивысшим приоритетом
infixl 9 !!             -- [1,2,3] !! 2
infixr 9 .              -- f . g x
infixr 8 ^, ^^, **      -- 2 ^ 3 -- 2.0 ^^ 3 -- 2.0 ^^ (-3) -- 2.0 ** 3.0
infixl 7 *, /, `quot`, `rem`, `div`, `mod`
infixl 6 +, -
infixr 5 ++, :
infix  4 ==, /=, <, <=, >=, >, `elem`, `notElem`
infixr 3 &&
infixr 2 ||
infixl 1 >>, >>=        -- монадический байнд
infixr 1 =<<            -- монадический байнд
infixr 0 $, $!, `seq`   -- применение с наименьшим приоритетом
-}
